<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Kubekub]]></title><description><![CDATA[Kubekub website.]]></description><link>https://www.kubekub.com/</link><image><url>https://www.kubekub.com//icons/icon-512x512.png</url><title>Kubekub</title><link>https://www.kubekub.com/</link></image><generator>Kubekub</generator><lastBuildDate>Thu, 14 Mar 2019 23:58:18 GMT</lastBuildDate><atom:link href="https://www.kubekub.com//rss.xml" rel="self" type="application/rss+xml"/><author><![CDATA[Juan Carlos Garcia]]></author><copyright><![CDATA[Copyright © Kubekub 2019. All Rights Reserved.]]></copyright><item><title><![CDATA[Infrastructure as code with Terraform and docker]]></title><description><![CDATA[One of the good practices in a data center or a cloud infrastructure is to manage the  infrastructure as code 
( http://www.thoughtworks.com/es/insights/blog/infrastructure-code-reason-smile ).
There are many different options in the market as  CloudFormation ,  Heat ,  terraform , etc. to create and provision the infrastructure and code. 
On Internet we can find different comparisons for the…]]></description><link>https://www.kubekub.com//blog/terraform-aws-wso2-esb-docker-sample/</link><guid isPermaLink="false">https://www.kubekub.com//blog/terraform-aws-wso2-esb-docker-sample/</guid><category><![CDATA[terraform]]></category><category><![CDATA[docker]]></category><category><![CDATA[wso2]]></category><category><![CDATA[esb]]></category><category><![CDATA[aws]]></category><dc:creator><![CDATA[Juan Carlos Garcia]]></dc:creator><pubDate>Wed, 26 Aug 2015 22:00:00 GMT</pubDate><content:encoded>&lt;p&gt;One of the good practices in a data center or a cloud infrastructure is to manage the [infrastructure as code]
(&lt;a href=&quot;http://www.thoughtworks.com/es/insights/blog/infrastructure-code-reason-smile&quot;&gt;http://www.thoughtworks.com/es/insights/blog/infrastructure-code-reason-smile&lt;/a&gt;).
There are many different options in the market as &lt;strong&gt;&lt;a href=&quot;https://aws.amazon.com/cloudformation/&quot;&gt;CloudFormation&lt;/a&gt;&lt;/strong&gt;, &lt;strong&gt;&lt;a href=&quot;https://wiki.openstack.org/wiki/Heat&quot;&gt;Heat&lt;/a&gt;&lt;/strong&gt;, &lt;strong&gt;&lt;a href=&quot;https://terraform.io/&quot;&gt;terraform&lt;/a&gt;&lt;/strong&gt;, etc. to create and provision the infrastructure and code.
On Internet we can find different comparisons for the tools:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.thoughtworks.com/es/insights/blog/choosing-right-tool-provision-aws-infrastructure&quot;&gt;thoughtworks.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://ypoonawala.wordpress.com/2014/12/14/terraform-vs-cloudformation-a-comparison-of-infra-management-tools/&quot;&gt;ypoonawala.wordpress.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.terraform.io/intro/vs/index.html&quot;&gt;www.terraform.io&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://aws.amazon.com/cloudformation/&quot;&gt;CloudFormation&lt;/a&gt;&lt;/strong&gt; and &lt;strong&gt;&lt;a href=&quot;https://wiki.openstack.org/wiki/Heat&quot;&gt;Heat&lt;/a&gt;&lt;/strong&gt; are specific for AWS and OpenStack, and &lt;strong&gt;&lt;a href=&quot;https://terraform.io/&quot;&gt;Terraform&lt;/a&gt;&lt;/strong&gt; can be used for multiple cloud providers.
In this article it&apos;s going to be explained how to create a simple infrastructure in &lt;a href=&quot;https://aws.amazon.com/&quot;&gt;AWS&lt;/a&gt; with &lt;strong&gt;&lt;a href=&quot;https://terraform.io/&quot;&gt;Terraform&lt;/a&gt;&lt;/strong&gt; and &lt;a href=&quot;https://www.docker.com/&quot;&gt;Docker&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The sample application will have an &lt;a href=&quot;https://aws.amazon.com/elasticloadbalancing/&quot;&gt;Elastic Load Balancer&lt;/a&gt;, an EC2 instance with a &lt;a href=&quot;http://wso2.com/products/enterprise-service-bus/&quot;&gt;WSO2 ESB&lt;/a&gt;, and an &lt;a href=&quot;http://axis.apache.org/axis2/java/core/&quot;&gt;axis server&lt;/a&gt; with a sample service. This sample is based in the &lt;a href=&quot;https://www.terraform.io/intro/examples/aws.html&quot;&gt;BASIC TWO-TIER AWS ARCHITECTURE&lt;/a&gt; from &lt;a href=&quot;https://terraform.io/&quot;&gt;Terraform&lt;/a&gt; samples and the WSO2 ESB samples.&lt;/p&gt;
&lt;h1&gt;AWS account&lt;/h1&gt;
&lt;p&gt;The sample can be executed in the &lt;a href=&quot;http://aws.amazon.com/free/&quot;&gt;AWS free tier&lt;/a&gt; without cost.&lt;/p&gt;
&lt;p&gt;First it&apos;s necessary to create an account in AWS or use an existing one.&lt;/p&gt;
&lt;p&gt;Once we have our AWS account, it&apos;s necessary to &lt;strong&gt;&lt;a href=&quot;http://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSGettingStartedGuide/AWSCredentials.html&quot;&gt;create a secret key&lt;/a&gt;&lt;/strong&gt; on aws.&lt;/p&gt;
&lt;p&gt;![Create secret key] (/media/posts/terraform-aws-wso2-esb-docker-sample/aws-iam-create-access-key.png)&lt;/p&gt;
&lt;p&gt;This secret key and password will allow to access AWS with the &lt;a href=&quot;http://docs.aws.amazon.com/AWSEC2/latest/APIReference/Welcome.html&quot;&gt;Amazon EC2 API&lt;/a&gt;, and internally &lt;a href=&quot;https://terraform.io/&quot;&gt;Terraform&lt;/a&gt; uses it.&lt;/p&gt;
&lt;h1&gt;Use of terraform&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://terraform.io/&quot;&gt;Terraform&lt;/a&gt; can be installed &lt;a href=&quot;https://www.terraform.io/intro/getting-started/install.html&quot;&gt;following the instructions&lt;/a&gt;, but we can avoid it using a &lt;a href=&quot;https://www.docker.com/&quot;&gt;Docker&lt;/a&gt; image doing a search in the &lt;strong&gt;&lt;a href=&quot;https://hub.docker.com/&quot;&gt;Docker Hub&lt;/a&gt;&lt;/strong&gt;. Using a &lt;a href=&quot;https://hub.docker.com/r/uzyexe/terraform/&quot;&gt;docker image&lt;/a&gt; it&apos;s not needed to install additional software in your computer, and it also allows to use &lt;a href=&quot;https://terraform.io/&quot;&gt;Terraform&lt;/a&gt; in unsupported operating systems. In a team everybody will use the same version of &lt;a href=&quot;https://terraform.io/&quot;&gt;Terraform&lt;/a&gt; if we specify it in the execution scripts.&lt;/p&gt;
&lt;p&gt;To obtain the &lt;a href=&quot;https://www.docker.com/&quot;&gt;Docker&lt;/a&gt; image, we can pull it, in this case:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;docker pull uzyexe/terraform
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Terraform project&lt;/h2&gt;
&lt;p&gt;Terraform uses text files to describe infrastructure and to set variables. These text files are called Terraform configurations and end in .tf. We can create the &lt;a href=&quot;https://terraform.io/&quot;&gt;Terraform&lt;/a&gt; files, using the &lt;a href=&quot;https://www.terraform.io/docs/configuration/syntax.html&quot;&gt;terraform dsl or in JSON format&lt;/a&gt; (all the &lt;strong&gt;.tf&lt;/strong&gt; files will be executed in parallel if there is no dependency between instructions). In this sample the configuration files will be:&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;outputs.tf&lt;/strong&gt;:&lt;/h3&gt;
&lt;p&gt;Outputs define values that will be highlighted to the user when Terraform applies:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;output &quot;ebs_address&quot; {
  value = &quot;${aws_elb.web.dns_name}&quot;
}

output &quot;ec_address&quot; {
  value = &quot;${aws_instance.web.dns_name}&quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;&lt;strong&gt;variables.tf&lt;/strong&gt;:&lt;/h3&gt;
&lt;p&gt;Definition for some input variables as the region, instance type and region, the keys, and passwords will be parameterized.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;variable &quot;key_name&quot; {
    description = &quot;Name of the SSH keypair to use in AWS.&quot;
}

variable &quot;key_path&quot; {
    description = &quot;Path to the private portion of the SSH key specified.&quot;
}

variable &quot;access_key&quot; {}
variable &quot;secret_key&quot; {}

variable &quot;aws_region&quot; {
    description = &quot;AWS region to launch servers.&quot;
    default = &quot;eu-west-1&quot;
}

# Ubuntu Server 14.04 LTS (x64)
variable &quot;aws_amis&quot; {
    default = {
        eu-west-1 = &quot;ami-5da23a2a&quot;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;&lt;strong&gt;terraform.tfvars&lt;/strong&gt;:&lt;/h3&gt;
&lt;p&gt;Replacement for the variables, in this file we put the user data information, for example the user key and password. This file should be added as ignored in the public git repository. We can store this files in private repositories (in bitbucket we can have &lt;strong&gt;[unlimited private repositories for free] (&lt;a href=&quot;https://bitbucket.org/plans&quot;&gt;https://bitbucket.org/plans&lt;/a&gt;)&lt;/strong&gt;)&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;main.tf&lt;/strong&gt;:&lt;/h3&gt;
&lt;p&gt;Main file with our code for the creation.&lt;/p&gt;
&lt;p&gt;In this file it&apos;s created an AWS security group, [Elastic Load Balancer] (&lt;a href=&quot;https://aws.amazon.com/elasticloadbalancing/&quot;&gt;https://aws.amazon.com/elasticloadbalancing/&lt;/a&gt;) and an AWS EC2 instance.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cloudcomputingpatterns.org/Elastic_Load_Balancer&quot;&gt;Elastic Load Balance Pattern&lt;/a&gt;:
![Elastic Load Balance Pattern] (/media/posts/terraform-aws-wso2-esb-docker-sample/elastic-load-balancer-pattern.png)&lt;/p&gt;
&lt;p&gt;With the [Elastic Load Balancer] (&lt;a href=&quot;https://aws.amazon.com/elasticloadbalancing/&quot;&gt;https://aws.amazon.com/elasticloadbalancing/&lt;/a&gt;) we would have in the future the possibility to dynamically add more services to our infrastructure.
The instance is provisioned with simple shell scripts installing &lt;a href=&quot;https://www.docker.com/&quot;&gt;Docker&lt;/a&gt; images. The instance can be also provisioned with a &lt;a href=&quot;https://aws.amazon.com/marketplace/help/200940360&quot;&gt;custom Amazon Machine Image (AMI)&lt;/a&gt; or with a provisioner like &lt;strong&gt;&lt;a href=&quot;https://www.packer.io/&quot;&gt;Packer&lt;/a&gt;&lt;/strong&gt;, &lt;strong&gt;&lt;a href=&quot;http://www.ansible.com/home&quot;&gt;Ansible&lt;/a&gt;&lt;/strong&gt;, &lt;strong&gt;&lt;a href=&quot;https://www.chef.io/&quot;&gt;Chef&lt;/a&gt;&lt;/strong&gt;, &lt;strong&gt;&lt;a href=&quot;https://puppetlabs.com/&quot;&gt;Puppet&lt;/a&gt;&lt;/strong&gt;... &lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;# Specify the provider and access details
provider &quot;aws&quot; {
    access_key = &quot;${var.access_key}&quot;
    secret_key = &quot;${var.secret_key}&quot;
    region = &quot;${var.aws_region}&quot;
}

# Our default security group to access
# the instances over SSH and HTTP
resource &quot;aws_security_group&quot; &quot;default&quot; {
    name = &quot;terraform_example&quot;
    description = &quot;Used in the terraform&quot;

    # SSH access from anywhere
    ingress {
        from_port = 22
        to_port = 22
        protocol = &quot;tcp&quot;
        cidr_blocks = [&quot;0.0.0.0/0&quot;]
    }

    # HTTP access from anywhere
    ingress {
        from_port = 443
        to_port = 443
        protocol = &quot;tcp&quot;
        cidr_blocks = [&quot;0.0.0.0/0&quot;]
    }
    
    # HTTP access from anywhere
    ingress {
        from_port = 80
        to_port = 80
        protocol = &quot;tcp&quot;
        cidr_blocks = [&quot;0.0.0.0/0&quot;]
    }

    # outbound internet access
    egress {
        from_port = 0
        to_port = 0
        protocol = &quot;-1&quot;
        cidr_blocks = [&quot;0.0.0.0/0&quot;]
    }
}


resource &quot;aws_elb&quot; &quot;web&quot; {
  name = &quot;terraform-example-elb&quot;

  # The same availability zone as our instance
  availability_zones = [&quot;${aws_instance.web.availability_zone}&quot;]

  listener {
    instance_port = 80
    instance_protocol = &quot;http&quot;
    lb_port = 80
    lb_protocol = &quot;http&quot;
  }
  
  # The instance is registered automatically
  instances = [&quot;${aws_instance.web.id}&quot;]
}

resource &quot;aws_instance&quot; &quot;web&quot; {
  # The connection block tells our provisioner how to
  # communicate with the resource (instance)
  connection {
    # The default username for our AMI
    user = &quot;ubuntu&quot;

    # The path to your keyfile
    key_file = &quot;${var.key_path}&quot;
  }

  instance_type = &quot;t1.micro&quot;

  # Lookup the correct AMI based on the region
  # we specified
  ami = &quot;${lookup(var.aws_amis, var.aws_region)}&quot;

  # The name of our SSH keypair you&apos;ve created and downloaded
  # from the AWS console.
  #
  # https://console.aws.amazon.com/ec2/v2/home?region=us-west-2#KeyPairs:
  #
  key_name = &quot;${var.key_name}&quot;

  # Our Security group to allow HTTP and SSH access
  security_groups = [&quot;${aws_security_group.default.name}&quot;]

  # We run a remote provisioner on the instance after creating it.
  provisioner &quot;file&quot; {
      source = &quot;./wso2-esb/&quot;
      destination = &quot;/tmp/&quot;
  } 
provisioner &quot;remote-exec&quot; {
   inline = [
        &quot;sh /tmp/install-docker.sh&quot;,
        &quot;sh /tmp/download-docker-images.sh&quot;,        
        &quot;sh /tmp/run-axis-server.sh&quot;,
        &quot;sh /tmp/run-esb.sh&quot;
    ]
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The shell scripts for provision the machine are simple scripts, creating an axis service and using the &lt;a href=&quot;http://wso2.com/products/enterprise-service-bus/&quot;&gt;WSO2 ESB&lt;/a&gt; as a proxy.
The idea of is to create an stateless instance, the ESB will proxy all the connections and do a logging (in the sample only in the log file, but can be in a remote statefull service, like a database or a &lt;a href=&quot;https://aws.amazon.com/s3/&quot;&gt;S3 bucket&lt;/a&gt;). Following the &lt;a href=&quot;(http://www.cloudcomputingpatterns.org/Stateless_Component)&quot;&gt;stateless machine pattern&lt;/a&gt; we can add an remove dynamically instances depending on the traffic. To provision new services and escalate will be really simple.&lt;/p&gt;
&lt;p&gt;![Stateless Pattern] (/media/posts/terraform-aws-wso2-esb-docker-sample//Stateless&lt;em&gt;component&lt;/em&gt;sketch.png)&lt;/p&gt;
&lt;p&gt;The shell script files are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;install-docker.sh&lt;/strong&gt;: &lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;#!/bin/sh
curl -sSL https://get.docker.com/ | sh
sudo usermod -aG docker ubuntu
echo added user to docker group
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This script executes the installation of &lt;a href=&quot;https://www.docker.com/&quot;&gt;Docker&lt;/a&gt; and adds the user in the &lt;a href=&quot;https://www.docker.com/&quot;&gt;Docker&lt;/a&gt; group.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;run-axis-server.sh&lt;/strong&gt;: &lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;#!/bin/sh
. /tmp/set-env.sh

sudo docker rm -f $AXIS_SERVER_NAME
sudo docker rm -f wso2-esb-samples-as

#Creates a container 
sudo docker run -d --name wso2-esb-samples-as -v $WSO2_ESB_PATH \
 jgpelaez/wso2-esb /bin/bash

mkdir -p target

axis_server_pid=$(sudo docker run \
  -d  \
  --volumes-from wso2-esb-samples-as \
  --name $AXIS_SERVER_NAME \
  webratio/ant sh $WSO2_ESB_SAMPLES_PATH/axis2Server/axis2server.sh -name $AXIS_SERVER_NAME)
  
echo &quot;container id&quot;. $axis_server_pid
sudo docker exec -d $axis_server_pid ant -f $WSO2_ESB_SAMPLES_PATH/axis2Server/src/SimpleStockQuoteService/build.xml
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This script executes a &lt;a href=&quot;https://www.docker.com/&quot;&gt;Docker&lt;/a&gt; container with ant executing an axis server. The execution code is in a volume with the &lt;a href=&quot;http://wso2.com/products/enterprise-service-bus/&quot;&gt;WSO2 ESB&lt;/a&gt; samples.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;run-axis-server.sh&lt;/strong&gt;: &lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;#!/bin/sh
. /tmp/set-env.sh

sudo docker rm -f wso2-esb-samples

sudo docker build -t jgpelaez/wso2-esb-samples ../utils/esb/

sudo docker run  \
    -d  \
    -p 443:9443 -p 80:8280 \
    -v $WSO2_ESB_PATH \
    --link wso2-esb-samples-axis-server:wso2-esb-samples-axis-server \
    --name wso2-esb-samples \
    jgpelaez/wso2-esb $WSO2_ESB_PATH/bin/wso2esb-samples.sh -sn 0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Runs a &lt;a href=&quot;https://www.docker.com/&quot;&gt;Docker&lt;/a&gt; container with a &lt;a href=&quot;http://wso2.com/products/enterprise-service-bus/&quot;&gt;WSO2 ESB&lt;/a&gt; configured with the sample number 0. The https 9443 port will be exposed outside through the standar 443, and the execution port 8280 with the 80 port.
The --link will create a link with the axis server, and the axis server port doesn&apos;t needs to expose the ports outside &lt;a href=&quot;https://www.docker.com/&quot;&gt;Docker&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Terraform execution&lt;/h2&gt;
&lt;p&gt;Before the execution, as it&apos;s necessary ssh access to the EC2 instance we need to &lt;strong&gt;create a key pai&lt;/strong&gt;r in the AWS console, going to &lt;strong&gt;EC2 dashboard&lt;/strong&gt;, &lt;strong&gt;Network &amp;#x26; security&lt;/strong&gt;:
&lt;img src=&quot;/media/posts/terraform-aws-wso2-esb-docker-sample/aws-create-key-pair.png&quot; alt=&quot;Create key pair&quot;&gt;&lt;/p&gt;
&lt;p&gt;Will create a &quot;.pem&quot; file, this file will allow to access &lt;a href=&quot;https://terraform.io/&quot;&gt;Terraform&lt;/a&gt; through ssh.&lt;/p&gt;
&lt;h3&gt;Execution plan:&lt;/h3&gt;
&lt;p&gt;The &lt;a href=&quot;https://terraform.io/&quot;&gt;Terraform&lt;/a&gt; plan command is used to create an execution plan. Our first execution will be:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;docker run \
    --rm \
    -v $(pwd):/data \
    -v /home/jgpelaez/git/ec2-instance/data/:/data-ssl \
    uzyexe/terraform plan \
    -var &apos;key_name=keypar2&apos; -var &apos;key_path=/data-ssl/keypar2.pem&apos;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With -v it´s sharing the host folders with the container, the /data for the .tf files and the /data-ssl for the key ar previously created.
The execution will create an initial plan file called &lt;strong&gt;terraform.tfstate&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;After the creation of the plan, can be applied and create the real infrastructure with the instruction apply:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;docker run \
    --rm \
    -v $(pwd):/data \
    -v /home/jgpelaez/git/ec2-instance/data/:/data-ssl \
    uzyexe/terraform apply \
    -var &apos;key_name=keypar2&apos; -var &apos;key_path=/data-ssl/keypar2.pem&apos;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Will create the infrasctructure in the AWS, and print the ouput variables:&lt;/p&gt;
&lt;p&gt;![terraform-apply-finised.png] (/media/posts/terraform-aws-wso2-esb-docker-sample/terraform-apply-finised.png)&lt;/p&gt;
&lt;p&gt;In the AWS console will appear all the structure defined in the &lt;strong&gt;.tf&lt;/strong&gt; files, a new running instance, one volume, a new Load Balancer and a new group:&lt;/p&gt;
&lt;p&gt;![aws-instances.png] (/media/posts/terraform-aws-wso2-esb-docker-sample/aws-instances.png)&lt;/p&gt;
&lt;p&gt;Checking the instance detail can obtain the public DNS, the &lt;a href=&quot;http://wso2.com/products/enterprise-service-bus/&quot;&gt;WSO2 ESB&lt;/a&gt; management console is not exposed through the load balancer, and normally it should be restricted to be acceded from an specific ip in a security group.&lt;/p&gt;
&lt;p&gt;![aws-instances.png] (/media/posts/terraform-aws-wso2-esb-docker-sample/aws-instance-detail.png)&lt;/p&gt;
&lt;p&gt;We can see in detail the security group created:&lt;/p&gt;
&lt;p&gt;![aws-security-groups.png] (/media/posts/terraform-aws-wso2-esb-docker-sample/aws-security-groups.png)&lt;/p&gt;
&lt;p&gt;We can see in detail the Elastic Load Balancer:&lt;/p&gt;
&lt;p&gt;![aws-elb.png] (/media/posts/terraform-aws-wso2-esb-docker-sample/aws-elb.png)&lt;/p&gt;
&lt;p&gt;Using the public DNS for the ec2 instance we can check if the &lt;a href=&quot;http://wso2.com/products/enterprise-service-bus/&quot;&gt;WSO2 ESB&lt;/a&gt; admin console is running (user and password are the default admin/admin)&lt;/p&gt;
&lt;p&gt;![logs] (/media/posts/terraform-aws-wso2-esb-docker-sample/wso2-esb-console.png)&lt;/p&gt;
&lt;h3&gt;Execute a client for the service:&lt;/h3&gt;
&lt;p&gt;As we are using the &lt;strong&gt;&lt;a href=&quot;https://docs.wso2.com/display/ESB481/Samples&quot;&gt;samples&lt;/a&gt;&lt;/strong&gt; from WSO2 ESB, it&apos;s possible to use the &lt;strong&gt;&lt;a href=&quot;https://docs.wso2.com/display/ESB481/Using+the+Sample+Clients&quot;&gt;sample client&lt;/a&gt;&lt;/strong&gt;. It can be executed in our local system, and will demonstrate if all the infrastructure is correctly working.&lt;/p&gt;
&lt;p&gt;In local can be also executed with &lt;a href=&quot;https://www.docker.com/&quot;&gt;Docker&lt;/a&gt;, using the script &lt;strong&gt;/wso2-esb/run-client.sh&lt;/strong&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;#!/bin/sh
. ./set-env.sh

WSO_ESB_SAMPLES_SERVER_NAME=$1

export CLIENT_ARGUMENTS=&quot;-Daddurl=http://$AXIS_SERVER_NAME:9000/services/SimpleStockQuoteService \
   -Dtrpurl=http://$WSO_ESB_SAMPLES_SERVER_NAME/&quot;
    
echo Running wso2 client sample with arguments: $CLIENT_ARGUMENTS

docker rm -f wso2-esb-samples-client
#Creates a container 
docker run -d --name wso2-esb-samples-client -v $WSO2_ESB_PATH \
 jgpelaez/wso2-esb /bin/bash

docker run \
  --volumes-from wso2-esb-samples-client \
  webratio/ant ant stockquote -f $WSO2_ESB_SAMPLES_ClIENT_BUILD \
   $CLIENT_ARGUMENTS
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The address will be the public DNS of the Elastic Load Balancer:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;sh run-client.sh terraform-example-elb-1103743156.eu-west-1.elb.amazonaws.com
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This command will send a SOAP request to the Elastic Load Balancer, the ELB will proxy the request to an instance (in this case there is only one in execution), the WSO2 ESB will log the input and ouput, and proxy to the Axis Server, and return the results to the client. In the WSO2 ESB management console we can see the logs:&lt;/p&gt;
&lt;p&gt;![logs] (/media/posts/terraform-aws-wso2-esb-docker-sample/wso2-esb-logs.png)&lt;/p&gt;
&lt;h3&gt;Remove resources:&lt;/h3&gt;
&lt;p&gt;For avoid charges in our AWS account, finally we can destroy the resources created, first we can ask to the plan what is going to be destroyed:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;docker run \
    --rm \
    -v $(pwd):/data \
    -v /home/jgpelaez/git/ec2-instance/data/:/data-ssl \
    uzyexe/terraform plan -destroy \
    -var &apos;key_name=keypar2&apos; -var &apos;key_path=/data-ssl/keypar2.pem&apos;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And remove everything with the destroy instruction, using &lt;a href=&quot;https://www.docker.com/&quot;&gt;Docker&lt;/a&gt; it&apos;s necessary to add the -force flag.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;docker run \
    --rm \
    -v $(pwd):/data \
    -v /home/jgpelaez/git/ec2-instance/data/:/data-ssl \
    uzyexe/terraform destroy \
    -var &apos;key_name=keypar2&apos; -var &apos;key_path=/data-ssl/keypar2.pem&apos; \
    -force
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;Conclusion&lt;/h1&gt;
&lt;p&gt;This is a very simple example of the use of &lt;a href=&quot;https://terraform.io/&quot;&gt;Terraform&lt;/a&gt; and &lt;a href=&quot;https://www.docker.com/&quot;&gt;Docker&lt;/a&gt; as infrastructure as code, in a real project it will be more complex and use other layers as database, etc. We can also use other interesting features like autoscale, or use terraform with other providers, or have the infrastucture using different providers at the same time. &lt;/p&gt;
&lt;p&gt;Terraform will also allow to do modifications using the concept of &lt;a href=&quot;https://terraform.io/docs/state/index.html&quot;&gt;state&lt;/a&gt;. The infrastructure as code will simplify our future changes, and gives and easy way to see our infrasctructure, and know wich resources we are using.&lt;/p&gt;
&lt;p&gt;With the stateless instances concept using &lt;a href=&quot;https://www.docker.com/&quot;&gt;Docker&lt;/a&gt; will be more simple to escalate our infrastructure simply adding new services in a very simple way.&lt;/p&gt;
&lt;h2&gt;Resources&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Source code in [github/jgpelaez] (&lt;a href=&quot;https://github.com/jgpelaez/terraform-aws-wso2-esb-docker-sample&quot;&gt;https://github.com/jgpelaez/terraform-aws-wso2-esb-docker-sample&lt;/a&gt;).&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Thanks / Contributions&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;If it&apos;s useful code you can favourite it in:
[GitHub] (&lt;a href=&quot;https://github.com/jgpelaez/terraform-aws-wso2-esb-docker-sample/stargazers&quot;&gt;https://github.com/jgpelaez/terraform-aws-wso2-esb-docker-sample/stargazers&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[Using Docker registry for WSO2 images]]></title><description><![CDATA[Introduction Once we know  how to create a Docker image  ( https://itscenario.wordpress.com/2014/11/09/dockerizing-wso2-esb/ ), if we want to share this image with the team, or use it in different environments, it´s possible to export it to a tar file, or use the  Dockerfile  ( https://docs.docker.com/reference/builder/ ) to build the image on each of the docker hosts where it will be used.
Having…]]></description><link>https://www.kubekub.com//blog/wso2-in-docker-registry/</link><guid isPermaLink="false">https://www.kubekub.com//blog/wso2-in-docker-registry/</guid><category><![CDATA[terraform]]></category><category><![CDATA[docker]]></category><category><![CDATA[wso2]]></category><category><![CDATA[esb]]></category><dc:creator><![CDATA[Juan Carlos Garcia]]></dc:creator><pubDate>Invalid Date</pubDate><content:encoded>&lt;h2&gt;Introduction&lt;/h2&gt;
&lt;p&gt;Once we know [how to create a Docker image] (&lt;a href=&quot;https://itscenario.wordpress.com/2014/11/09/dockerizing-wso2-esb/&quot;&gt;https://itscenario.wordpress.com/2014/11/09/dockerizing-wso2-esb/&lt;/a&gt;), if we want to share this image with the team, or use it in different environments, it´s possible to export it to a tar file, or use the [Dockerfile] (&lt;a href=&quot;https://docs.docker.com/reference/builder/&quot;&gt;https://docs.docker.com/reference/builder/&lt;/a&gt;) to build the image on each of the docker hosts where it will be used.
Having to &lt;strong&gt;rebuild the image&lt;/strong&gt; on the pc of each of the components of your team is not very practical. Would not it be better if we could download images ready to use? To resolve this problem Docker has a solution called registry, which can raise and download our images.&lt;/p&gt;
&lt;p&gt;One of the great advantages is to be able to test different versions of a product only changing the version of the image to download.&lt;/p&gt;
&lt;p&gt;We can install a private registry or use the [public registry available in Docker] (&lt;a href=&quot;https://registry.hub.docker.com/&quot;&gt;https://registry.hub.docker.com/&lt;/a&gt;). This registry can be used by any user, and has a search function to see if another user has added the image we want.&lt;/p&gt;
&lt;p&gt;![Registration docker] (/media/wso2-in-docker-registry/search-docker-registry.png)&lt;/p&gt;
&lt;p&gt;If you use an image uploaded by another user is recommended to use the marked with &quot;automatic building&quot;. In these images we can see how it has been created with the [Dockerfile] (&lt;a href=&quot;https://docs.docker.com/reference/builder/&quot;&gt;https://docs.docker.com/reference/builder/&lt;/a&gt;), if the image has been uploaded directly by a user whe should not trust it, because the image can contain malicious software.&lt;/p&gt;
&lt;p&gt;For the use in production of Docker it is recommended to write our own images, as the images of the registry can be deleted by the user. It is also recommended to use images marked as official, these have been developed either by the vendor, by the Docker team, or by popular users in the docker registry.&lt;/p&gt;
&lt;p&gt;![Registration docker] (/media/wso2-in-docker-registry/docker-official-repo.png)&lt;/p&gt;
&lt;p&gt;In this post we will explain how to upload images of WSO2 in the Docker regitry.&lt;/p&gt;
&lt;h2&gt;Creating images in the public registry of Docker&lt;/h2&gt;
&lt;p&gt;First we create a public repository on github or bitbucket or &lt;a href=&quot;https://github.com/jgpelaez/docker-wso2-esb.git&quot;&gt;fork an existing one&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;In this repository we add the [Dockerfile] (&lt;a href=&quot;https://docs.docker.com/reference/builder/&quot;&gt;https://docs.docker.com/reference/builder/&lt;/a&gt;):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-docker&quot;&gt;FROM java:openjdk-7

MAINTAINER juancarlosgpelaez@gmail.com

ENV WSO2_URL=https://s3-us-west-2.amazonaws.com/wso2-stratos
ENV WSO2_SOFT_VER=4.8.1
RUN  \
    mkdir -p /opt &amp;#x26;&amp;#x26; \
    wget -P /opt $WSO2_URL/wso2esb-$WSO2_SOFT_VER.zip &amp;#x26;&amp;#x26; \
    unzip /opt/wso2esb-$WSO2_SOFT_VER.zip -d /opt &amp;#x26;&amp;#x26; \
    rm /opt/wso2esb-$WSO2_SOFT_VER.zip

# ESB https port
EXPOSE 9443
# ESB http pass-through transport port
EXPOSE 8280
# ESB https pass-through transport port
EXPOSE 8243

ENV JAVA_HOME=/usr
CMD [&quot;/opt/wso2esb-4.8.1/bin/wso2server.sh&quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Create a user in the [docker registry] (&lt;a href=&quot;https://registry.hub.docker.com/&quot;&gt;https://registry.hub.docker.com/&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/wso2-in-docker-registry/docker-registry-signup.png&quot; alt=&quot;registry in docker&quot;&gt;&lt;/p&gt;
&lt;p&gt;We can use our GitHub user for registration.&lt;/p&gt;
&lt;p&gt;Once we have our account we can create a new repository with &lt;em&gt;automatic build&lt;/em&gt;, the registry will read our [Dockerfile]  (&lt;a href=&quot;https://docs.docker.com/reference/builder/&quot;&gt;https://docs.docker.com/reference/builder/&lt;/a&gt;) and automatically perform the build:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/wso2-in-docker-registry/docker-registry-repositories.png&quot; alt=&quot;docker registry&quot;&gt;&lt;/p&gt;
&lt;p&gt;It is possible to chose our bitbucket account or github:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/wso2-in-docker-registry/docker-registry-git-source.png&quot; alt=&quot;docker registry&quot;&gt;&lt;/p&gt;
&lt;p&gt;And select the repository where the [Dockerfile] (&lt;a href=&quot;https://docs.docker.com/reference/builder/&quot;&gt;https://docs.docker.com/reference/builder/&lt;/a&gt;) is:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/wso2-in-docker-registry/docker-registry-git-source-repository.png&quot; alt=&quot;docker registry&quot;&gt;&lt;/p&gt;
&lt;p&gt;We can select the path of the [Dockerfile] (&lt;a href=&quot;https://docs.docker.com/reference/builder/&quot;&gt;https://docs.docker.com/reference/builder/&lt;/a&gt;). In this case will add several  [Dockerfile] (&lt;a href=&quot;https://docs.docker.com/reference/builder/&quot;&gt;https://docs.docker.com/reference/builder/&lt;/a&gt;) for different versions of the WSO2 ESB.
We can also change the name of the repository, the convention used for the git repository is &lt;strong&gt;docker-[vendor]-[app]&lt;/strong&gt; and for the registry &lt;strong&gt;[vendor]-[app]&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/wso2-in-docker-registry/docker-registry-repository-creation.png&quot; alt=&quot;Repository creation&quot;&gt;&lt;/p&gt;
&lt;p&gt;The build can be executed manually, but normally will not be necessary, as when we change a file in our repository for git, the docker build runs automatically.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/wso2-in-docker-registry/docker-registry-repository-build-details.png&quot; alt=&quot;docker registry&quot;&gt;&lt;/p&gt;
&lt;h2&gt;Using the public Docker registry&lt;/h2&gt;
&lt;p&gt;Once the images have bee created or we want to test a new image uploaded by another user we can do it with the run command, for example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker run -p 19443:9443 jgpelaez/wso2-esb
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This command runs an instance indicating the image name &lt;strong&gt;(jgpelaez/wso2-esb)&lt;/strong&gt;, the container port &lt;strong&gt;9443&lt;/strong&gt; will be exposed to the host on port 19443 and the tag used will&apos;latest&apos;. To see more execution parameters we can execute the command &lt;strong&gt;&apos;docker --help&apos;&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;In this case we see the &lt;strong&gt;WSO2 ESB management console&lt;/strong&gt; with the URL in your browser:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;https://localhost:19443/carbon/admin/login.jsp
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;/media/wso2-in-docker-registry/docker-wso2-esb-admin.png&quot; alt=&quot;docker registry&quot;&gt;&lt;/p&gt;
&lt;p&gt;The host to set in the url depends on the operating system in which docker is executed. If it has natively docker (ubuntu, redhat, etc) will be localhost, if it&apos;s use boot2docker (Windows / Mac), will be the IP of the virtual machine created by [boot2docker] (&lt;a href=&quot;http://boot2docker.io/&quot;&gt;http://boot2docker.io/&lt;/a&gt;) (by defect usually 192.168.59.103).&lt;/p&gt;
&lt;p&gt;Among other options we could try the wso2 samples with the command:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker run -p 19443:9443 jgpelaez/wso2-esb/opt/wso2esb-4.8.1/bin/wso2esb-samples.sh -sn [sample number]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A &lt;strong&gt;great advantage&lt;/strong&gt; provided by using docker is to run different instances of the same image in the same machine,s modifying the port, always using one available, or with the &apos;-P&apos; argument to automatically assign an available port. It&apos;s possible to see the running containers with  the instruction:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker ps
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;CONTAINER ID        IMAGE               COMMAND                CREATED             STATUS              PORTS                                        NAMES
dbfa29da863f        jgpelaez/wso2-esb   &quot;/opt/wso2esb-4.8.1/  44 minutes ago      Up 44 minutes       8243/tcp, 8280/tcp, 0.0.0.0:9443-&gt;9443/tcp   happy_goodall      
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;The use of Linux containers (in this case Docker) and an the a image registry can help us a lot to get isolated and repeatable environments.
Docker registry or a private registry will help us in development for all team members to work with the same configuration.
From a DevOps perspective, if we use Docker images for development, test and production with a registry, we test in a very similar environment in all phases of project / product, and will minify configuration errors that could reach production.&lt;/p&gt;
&lt;h2&gt;Resources&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Source code in [github/jgpelaez] (&lt;a href=&quot;https://github.com/jgpelaez/docker-wso2-esb.git&quot;&gt;https://github.com/jgpelaez/docker-wso2-esb.git&lt;/a&gt;).&lt;/li&gt;
&lt;li&gt;Image of the WSO2 ESB [Docker repository] (&lt;a href=&quot;https://registry.hub.docker.com/u/jgpelaez/wso2-esb/&quot;&gt;https://registry.hub.docker.com/u/jgpelaez/wso2-esb/&lt;/a&gt;) &lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Thanks / Contributions&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;You can contribute to the Docker registry: &lt;a href=&quot;https://github.com/jgpelaez/docker-wso2-esb&quot;&gt;https://github.com/jgpelaez/docker-wso2-esb&lt;/a&gt; creating &quot;pull requests&quot;&lt;/li&gt;
&lt;li&gt;If it seems useful code you can favourite it in:
[GitHub] (&lt;a href=&quot;https://github.com/jgpelaez/docker-wso2-esb/stargazers&quot;&gt;https://github.com/jgpelaez/docker-wso2-esb/stargazers&lt;/a&gt;)
[Docker Registry] (&lt;a href=&quot;https://registry.hub.docker.com/u/jgpelaez/wso2-esb/&quot;&gt;https://registry.hub.docker.com/u/jgpelaez/wso2-esb/&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item></channel></rss>